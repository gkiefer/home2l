#!/usr/bin/python3

# This file is part of the Home2L project.
#
# (C) 2025 Gundolf Kiefer
#
# Home2L is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Home2L is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Home2L. If not, see <https://www.gnu.org/licenses/>.


import os
import subprocess
import shutil
import sys
import socket
import pytz
import tzlocal

import home2l

from pathlib import Path
from datetime import datetime, timedelta, date, time
from icalendar import Calendar, Event, vDatetime, vRecur
import recurring_ical_events


# Option defaults...
optVdirRoot = None
optSocket = None
  # If set, listen on the specified port or unix domain socket.
  # By default, the server listens on the unix domain socket at '<Home2L var>/home2l-pimd.sock'.
  # If another socket file is given, the absolute path must be supplied.
optSyncInterval = 5
  # Synchronization interval in minutes




############################## Helpers #########################################


localTimeZone = tzlocal.get_localzone()


def eidEncode (uid, rid = None):
  """Return an extended ID (EID) based on a UID and a RECURRENCE-ID."""
  if not uid: return None
  if rid: return f"{uid}/{rid}"
  else: return uid


def eidDecode (eid):
  """Return the UID and RECURRENCE-ID from an extended ID (EID)."""
  if not eid: return None, None
  parts = eid.strip ().split ("/")
  if len (parts) > 1: return parts[0], parts[1]
  else: return parts[0], None


def eidFromEvent (event, autoRid = False):
  """Return the EID of an event or 'None' if 'event' is not an event."""
  if not isinstance (event, Event): return None
  # ~ print ("### Not an event, but '{}: {}".format (type (event), str (event)))
  eid = event["UID"].to_ical ().decode ("utf-8")
  if event.has_key ("RECURRENCE-ID"):
    eid = eid + "/" + event["RECURRENCE-ID"].to_ical ().decode ("utf-8")
  elif autoRid and event.has_key ("RRULE"):
    # Event is instance of a recurrence, but has no recurrence ID:
    # Add the starting date as a proposed recurrence ID.
    # If this entry is changed in Home2L, we have one, and the submission
    # will by default be interpreted as an edit to the single instance.
    eid = eid + "/" + event["DTSTART"].to_ical ().decode ("utf-8")
  return eid





############################## Remind Parsing ##################################


# Remind syntax support
# =====================
#
#
# 1. Expressions accepted on change/add operations
# ------------------------------------------------
#
# The following reminder formats are supported:
#
# a) single, timed events -> mapped from "AT" and "DURATION" clauses
#
# b) all-day events -> eventually mapped from "*1 UNTIL" clauses, if spanning multiple days
#
# The following formats are only supported without ID clause (since never generated by pimd):
#
# c) "*7 UNTIL ..." for lectures etc.
#    -> mapped to "FREQ=WEEKLY;.*UNTIL=<datetime>[;.*|$]"
#
# d) "<month> <day>" or "<day> <month>" - for anniversaries etc.
#    -> mapped to "RRULE;FREQ=YEARLY.*" with a starting year of 1971 (== year of first microprocessor / Unix / C)
#
#
# 2. Expressions potentially emitted on list operations
# -----------------------------------------------------
#
# An application must accept the following forms, but can also rely that no
# other type of expressions are emitted:
#
# a) Normal event
#
#      <yyyy>-<mm>-<dd> AT <hh>:<mm> DUR <hh>:<mm> MSG <msg> @<eid>
#
#    The duration may be long, so that the event may cover multiple days.
#
# b) All-day event (1 day)
#
#      <yyyy>-<mm>-<dd> MSG <msg> @<eid>
#
# c) Multi-day event
#
#      <yyyy>-<mm>-<dd> *1 UNTIL <yyyy>-<mm>-<dd> MSG <msg> @<eid>
#
#    Such events never have times. They are equivalent to normal events with
#    a starting time of 00:00 and a duration of n*24 hours.
#
# The part up to "MSG" can be parsed using whitespace as a separator.
# However, the message <msg> may contain whitespaces.
# The <eid> part does not contain whitespaces, so that it can be extracted by
# searching for the '@' character from the end of the string.
#
# The <msg> part does not contain non-printable characters. If present in a
# iCal entry / WebDAV calendar, such characters are replaced by space (' ').
# Also, any ';' inside 'SUMMARY' or 'LOCATION' fields are replaced by ',', so
# that the semikolon can be used as a delimiter between these two fields.


transNonprintable = str.maketrans ({ c: ' ' for c in range(0, sys.maxunicode + 1) if not chr (c).isprintable() })
transMsgUnsupported = str.maketrans ({ ';': ','})


def remindSanitizeMsg (msg):
  """Sanitize message fields (SUMMARY or LOCATION) to contain no non-printable character and no ';'."""
  return msg.translate (transNonprintable).translate (transMsgUnsupported)


remindDayNames = ( "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" )
remindMonthNames = ( "Dec", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov" )


def remindParseDay (str):
  try:
    for n in range (7):
      if str.lower () [0:3] == remindDayNames [n].lower (): return n
  except: pass
  return None


def remindParseMonth (str):
  try:
    for n in range (12):
      #print "# ", n, " str: ", str.lower (), " month: ", remindMonthNames [n].lower ()
      if str.lower () [0:3] == remindMonthNames [n].lower (): return (n + 11) % 12 + 1
  except: pass
  return None


def remindDay (n):
  return remindDayNames [n % 7]


def remindMonth (n):
  return remindMonthNames [n % 12]


def eventToReminder (ev):
  """Get a reminder entry from an icalendar.Event object."""

  # Determine EID (extended ID, composed of UID and eventually RECURRENCE-ID) ...
  eid = eidFromEvent (ev, autoRid = True)
  uid, rid = eidDecode (eid)

  # Determine times ...
  t0 = ev["DTSTART"].dt
  # ~ print (f"#    t0 = {t0}")
  if isinstance (t0, datetime): t0 = t0.astimezone (localTimeZone)
  else: t0 = datetime.combine (t0, time (0))
  if ev.has_key ("DTEND"):
    t1 = ev["DTEND"].dt
    if isinstance (t1, datetime): t1 = t1.astimezone (localTimeZone)
    else: t1 = datetime.combine (t1, time (0))
    dt =  t1 - t0
  elif ev.has_key ("DURATON"):
    dt = ev["DURATON"].dt
    t1 = t0 + dt
  else:
    if t0.hour == 0 and t0.minute == 0 and t0.second == 0:
      dt = timedelta (days=1)    # single-day all-day event ...
      t1 = t0 + dt
  allday = (t0.hour == 0 and t0.minute == 0 and t0.second == 0 and t1.hour == 0 and t1.minute == 0 and t1.second == 0)

  # Determine message part (= SUMMARY + LOCATION) ...
  msg = remindSanitizeMsg (ev["SUMMARY"])
  if ev.has_key ("LOCATION"):
    loc = remindSanitizeMsg (ev["LOCATION"])
    msg = msg + "; " + loc

  # Output remind record ...
  if allday and dt.days == 1:
    # All-day event (single or repeated) ...
    ret = "{:04}-{:02}-{:02}   MSG {}   @{}".format (t0.year, t0.month, t0.day, msg, eid)
  elif allday and rid == None:
    # Output multi-day event as a repeated event ...
    # Note: This only works if it is not already part of a reccurence!
    tLast = t1 - timedelta (days = 1)
    ret = "{:04}-{:02}-{:02} *1 UNTIL {:04}-{:02}-{:02}   MSG {}   @{}".format (
              t0.year, t0.month, t0.day, tLast.year, tLast.month, tLast.day, msg, uid
            )
  else:
    # Normal events ...
    durHours = 24 * dt.days + int (dt.seconds / 3600)
    durMinutes = int (dt.seconds / 60) % 60
    ret = "{:04}-{:02}-{:02} AT {:02}:{:02} DUR {}:{:02}   MSG {}   @{}".format (
              t0.year, t0.month, t0.day, t0.hour, t0.minute, durHours, durMinutes, msg, eid
            )

  # Done ...
  return ret


def eventPatchFromReminder (event, rem):
  """Apply a reminder to an icalendar.Event object."""

  # ~ print (f"# eventPatchFromReminder (<event>, '{rem}')")

  # Split 'rem' into a time part ('timePart'), a message part ('msgPart') ...
  msgIdx = rem.lower ().find (" msg ")
  if msgIdx < 0: raise SyntaxError ("No MSG part or missing time: " + rem)         # no 'msg' part
  timePart = rem[:msgIdx].lower ().split ()
  msgPart = rem[msgIdx+5:].split (";", 1)
  # ~ print (f"#   timePart = {timePart}")

  # Parse 'timePart' ...
  haveYear0 = False     # (stored in 'year0')
  haveMonth0 = False    # (stored in 'month0')
  haveDay0 = False      # (stored in 'day0')
  inUntil = False
  haveUntil = False
  haveYear1 = False         # refers to "until" date (stored in 'Year1')
  haveMonth1 = False        # refers to "until" date (stored in 'month1')
  haveDay1 = False          # refers to "until" date (stored in 'day1')
  inAt = False              # "at" keyword read => next time is "at" time
  haveAt = False            # (stored in '(atHour, atMin)')
  inDur = False             # "dur[ation]" keyword read => next time is "duration" time
  haveDur = False           # stored in ('durHour, durMinute')
  haveWeekly = False        # "*7"
  haveDaily = False         # "*1" for multi-day all-day events
  # Note: The "until" date may either refer to
  #       - the end of a multi-day all-day event or
  #       - the last instance of a weekly repetition.
  if timePart[0] == "rem":
    timePart = timePart [1:]
  while timePart != []:
    cur = timePart[0]
    timePart = timePart [1:]

    # times...
    if inAt or inDur:
      t = cur.split (':')
      if len(t) != 2: raise SyntaxError (f"Invalid time '{cur}'.")
      if inAt:    atHour, atMinute, haveAt, inAt = int (t[0]), int (t[1]), True, False
      elif inDur: durHour, durMinute, haveDur, inDur = int (t[0]), int (t[1]), True, False
      else: raise SyntaxError
      continue

    # keywords...
    # ~ print (f"#  cur='{cur}'")
    if   cur[:3] == "unt": inUntil = True
    elif cur == "at": inAt = True
    elif cur[:3] == "dur": inDur = True
    elif cur == "*7": haveWeekly = True
    elif cur == "*1": haveDaily = True

    # dates in short notation...
    try:
      dt = datetime.strptime (cur, "%Y-%m-%d")
      if inUntil:
        year1, month1, day1 = dt.year, dt.month, dt.day
        haveYear1, haveMonth1, haveDay1 = True, True, True
      else:
        year0, month0, day0 = dt.year, dt.month, dt.day
        haveYear0, haveMonth0, haveDay0 = True, True, True
    except ValueError: pass

    # date parts...
    try:
      x = int (cur)
      if x > 1900:
        if inUntil: year1, haveYear1 = x, True
        else:       year0, haveYear0 = x, True
      if x >= 1 and x <= 31:
        if inUntil: day1, haveDay1 = x, True
        else:       day0, haveDay0 = x, True
    except: pass
    x = remindParseMonth (cur)
    if x:
      if inUntil: month1, haveMonth1 = x, True
      else:       month0, haveMonth0 = x, True

  # end while

  #print "# day0 = ", day0, " month0 = ", month0

  # Prepare event object ...
  for key in ( "DTSTART", "DTEND", "RRULE", "SUMMARY", "LOCATION", "DESCRIPTION" ):
    if event.has_key (key): del event [key]
  if event.has_key ("SEQUENCE"): event["SEQUENCE"] = event["SEQUENCE"] + 1
  else: event.add ("SEQUENCE", 1)

  # Write time info to event ...
  haveUntil = haveYear1 or haveMonth1 or haveDay1
  isAllDay = not haveAt
  isYearly = not haveYear0
  isWeekly = haveWeekly
  isDaily = haveDaily
  #     "DTSTART" ...
  if not haveDay0 or not haveMonth0: raise SyntaxError
  if not haveYear0: year0 = 1971        # magic year for yearly events (original year got lost when converting to remind)
  if not haveAt: atHour, atMinute = 0, 0
  #print "# month0 = ", month0, " day0 = ", day0
  #print "# atHour = %i, atMinute = %i" % (atHour, atMinute)
  dt0 = datetime (year0, month0, day0, atHour, atMinute)
  event.add ("DTSTART", dt0)
  #     "DTEND"...
  dt1 = dt0
  if haveDur: dt1 += timedelta (hours = durHour, minutes = durMinute)
  if isAllDay and haveUntil:
    if haveDay1: dt1 = dt1.replace (day = 1)   # dummy to avoid "ValueError: day is out of range for month"!
    if haveYear1: dt1 = dt1.replace (year = year1)
    if haveMonth1: dt1 = dt1.replace (month = month1)
    if haveDay1: dt1 = dt1.replace (day = day1)
    dt1 += timedelta (days = 1)
    #print "# all-day: ", dt1, haveYear1, haveMonth1, haveDay1
    #if haveDay1: print "#   day1 = ", day1
  # ~ print ("#   dt0={}, dt1={}, durHour={}, durMinute={}".format (str (dt0), str (dt1), durHour, durMinute))
  event.add ("DTEND", dt1)
  #     "RRULE"...
  if isYearly:
    # ~ print ("#   yearly!")
    rrule = vRecur ()
    rrule ["freq"] = "yearly"
    event.add ("RRULE", rrule)
  if isWeekly or (isDaily and not isAllDay):
    # ~ print ("#   weekly or daily!")
    rrule = vRecur ()
    rrule ["freq"] = "weekly" if isWeekly else "daily"
    if haveYear1 or haveMonth1 or haveDay1:
      # ~ raise SyntaxError ("Recurrence without valid end date: " + rem)
      dt1 = dt0
      if haveDay1: dt1 = dt1.replace (day = 1)   # dummy to avoid "ValueError: day is out of range for month"!
      if haveYear1: dt1 = dt1.replace (year = year1)
      if haveMonth1: dt1 = dt1.replace (month = month1)
      if haveDay1: dt1 = dt1.replace (day = day1)
      rrule ["until"] = dt1
    event.add ("RRULE", rrule)

  # Write message part to event ...
  event.add ("SUMMARY", msgPart[0].strip ())
  try:
    s = msgPart[1].strip ()
    if s != "": event.add ("LOCATION", s)
  except IndexError: pass






############################## Calendar ########################################


class VDir:
  """
  Cached contents of a VDir
  """


  def __init__(self, name):
    self.cache = {}
      # Stores tuples (mtime, eids, ical) for a file name.
      #   Key is the file name without path.
      #   'mtime' is the file's last modification time.
      #   'eids' is the set of all EIDs found in that file.
      #   'ical' is the file content (as a raw text).
    self.name = name
    self.cacheFileByEid = {}
    self.cacheColor = None        # calendar color as cached
    self.cacheDisplayName = None  # calendar display name as cached


  def getName (self):
    return self.name


  def getPath (self):
    return Path (optVdirRoot, self.name)


  def getDisplayName (self, default = "-"):
    return self.cacheDisplayName if self.cacheDisplayName else default


  def getColor (self, default = "-"):
    return self.cacheColor if self.cacheColor else default


  def cacheUpdate (self):
    print ("INFO: Updating '{}' ...".format (self.name), flush = True)
    deleted = set (self.cache.keys ())
    # ~ print (f"### {self.name}")

    # Read directory and check all .ics files ...
    for pn in self.getPath ().glob ("*.ics"):
      # ~ print (f"### {pn}")
      deleted.discard (pn.name)

      # Check if file is still in cache ...
      dirty = True
      mtimeFile = pn.stat ().st_mtime
      if pn.name in self.cache:
        mtime, eids, ical = self.cache[pn.name]
        if mtime == mtimeFile: dirty = False

      # Read file if necessary ...
      if dirty:
        print ("INFO: Reading '{}'.".format (str (pn)), flush = True)
        ical = pn.read_text ()
        # ~ with open (str (pn), "r") as f: ical = f.read ()
        cal = Calendar.from_ical (ical)
        eids = set ()
        for ev in cal.subcomponents:
          eid = eidFromEvent (ev)
          if eid: eids.add (eid)
        self.cache [pn.name] = (mtimeFile, eids, ical)
        # ~ print (f"### eids = {eids}")
        for eid in eids: self.cacheFileByEid [eid] = pn.name

    # Remove deleted files from cache ...
    for fname in deleted:
      print ("INFO: Forgetting '{}'.".format (fname), flush = True)
      del self.cache[fname]

    # Read metadata ...
    try:
      self.cacheDisplayName = Path (self.getPath (), "displayname").read_text ().strip ()
    except FileNotFoundError:
      self.cacheDisplayName = None
    try:
      self.cacheColor = Path (self.getPath (), "color").read_text ().strip ()
    except FileNotFoundError:
      self.cacheColor = None


  def cacheGetFile (self, eid):
    # ~ print (f"### cacheGetFile ({eid}): cacheFileByEid = {self.cacheFileByEid}")
    if not eid in self.cacheFileByEid: return None
    ret = self.cacheFileByEid [eid]
    # Sanity (the map entry may be outdated) ...
    if not ret in self.cache: return None
    mtime, eids, ical = self.cache [ret]
    # ~ print (f"###   eids = {eids}")
    if not eid in eids:
      del self.cacheFileByEid [eid]
      return None
    # Done ...
    return ret


  def cacheGetCalendar (self, eid, fname = None):
    """Get icalendar.Calendar object for a given EID.

    Passing the file name if known speeds up execution.
    """
    if not fname: fname = self.cacheGetFile (eid)
    if not fname: return None

    mtime, eids, ical = self.cache [fname]
    return Calendar.from_ical (ical)


  def cacheGetEvent (self, eid, calendar = None):
    """Get icalendar.Event object for a given EID.

    Passing the calendar object if known speeds up execution.
    """
    if not calendar: calendar = self.cacheGetCalendar (eid)
    if not calendar: return None

    # ~ print (f"### cacheGetEvent ({eid}) ...")
    for comp in calendar.subcomponents:
      if eidFromEvent (comp) == eid: return comp


  def cacheWriteCalendar (self, fname, calendar):
    """Write calendar file and update the cache.

    If 'calendar' is None, the file is deleted.
    """
    pn = Path (self.getPath (), fname)
    if calendar:
      print ("INFO: Writing '{}'".format (str (pn)), flush = True)
      pn.write_text (calendar.to_ical ().decode ("utf-8"))
    else:
      print ("INFO: Removing '{}'".format (str (pn)), flush = True)
      pn.unlink ()
    self.cacheUpdate ()


  def getEventList (self, dateFrom, dateTo):
    """Get an event list.

    Output lines starting with 'E:' are error messages to be presented to the user.
    A line starting with '.' indicates the end of the list.
    The syntax of all other lines are described in the docomentation below
    'Remind syntax support' / 'Expressions potentially emitted on list operations'.
    """
    ret = ""
    for fn, (mtime, eids, ical) in self.cache.items ():
      cal = Calendar.from_ical (ical)
      for ev in recurring_ical_events.of (cal, keep_recurrence_attributes=True).between (dateFrom, dateTo):
        if ev.is_broken or len (ev.errors) > 0:
          ret += "E: {}: {}\n".format (fn, str (ev.errors))
        else:
          ret += eventToReminder (ev) + "\n"
    return ret


  def delEvent (self, eid):
    """Delete an event or event instance."""

    # Determine UID, RID and file name ...
    uid, rid = eidDecode (eid)
    fname = self.cacheGetFile (uid)   # get file of base UID, since the RID may be virtual
    if not fname: raise SyntaxError (f"Not such event: {eid}")
    # ~ print (f"### fname = {fname}, uid = {uid}, rid = {rid}")

    # Standard case: Not an instance of a recurrence, we will delete the calendar file ...
    calendar = None

    # Special case: Instance of a recurrence, we may need to modify an existing calendar file ...
    if rid != None:
      calendar = self.cacheGetCalendar (uid, fname)
        # pass UID to get the base calendar, the RID may not exist, but need to be added to EXDATE
      if not calendar: raise SyntaxError (f"Not such event: {eid}")
      event = self.cacheGetEvent (eid, calendar)

      # If a dedicated event exists: delete it ...
      if event:
        calendar.subcomponents.remove (event)
          # NOTE [2025-02-21]: This is improper, but at the time of this writing,
          #   icalender does not provide an API function to delete a subcomponent

      # If no dedicated event exists: add the date of this instance to EXDATE ...
      else:
        baseEvent = self.cacheGetEvent (uid, calendar)
        if not baseEvent: raise SyntaxError (f"Not such base event: {uid}")
        baseEvent.add ("EXDATE", vDatetime.from_ical (rid))
          # NOTE: We only have the RID to identify the date to be excluded.

        # Check, if we have excluded all single events, and if so, the whole
        # calendar can be deleted ...
        if baseEvent["RRULE"].has_key ("UNTIL"):    # avoid check for infin
          haveInstance = False
          for inst in recurring_ical_events.of (calendar).all ():
            # Note [2025-02-21]: The 'all()' method is documented to return an iterator,
            #   but in practical tests, it returned a list. The for loop can deal with
            #   both, and it is interrupted in the first iteration to minimize CPU
            #   effort, if we got an iterator for lots of events.
            haveInstance = True
            break
          if not haveInstance:
            print (f"INFO: Last instance of reccuring event deleted: {fname}", flush = True)
            calendar = None

    # Write back modifications or delete calendar ...
    self.cacheWriteCalendar (fname, calendar)


  def chgEvent (self, rem):
    """Change an event based on a remind-compatible definition string."""

    # Split 'rem' into a the base part and the EID ('eid', 'uid', 'rid') ...
    eidIdx = rem.rfind (" @")
    if eidIdx < 0:
      remMain = rem.strip ()
      eid = None
    else:
      remMain = rem[:eidIdx].strip ()
      eid = rem[eidIdx+2:].strip ()
    uid, rid = eidDecode (eid)
    # ~ print (f"### eid = {eid}, uid = {uid}, rid = {rid}")

    # Determine and sanitize EID, UID, RID and determine existing file name ...
    # (-> 'fname', 'eid', 'uid', 'rid')
    if not uid:
      # Create a new UID ...
      n = int ((datetime.now() - datetime (1971,5,23)).total_seconds() * 8) % 100000000
      while not uid or self.cacheGetFile (uid) or (uid + ".ics") in self.cache:
        # Neither the UID nor a file of its name must exist.
        uid = "home2l-{:08}".format (n)
        n += 1
      fname, eid, rid = None, uid, None
    else:
      fname = self.cacheGetFile (uid)
    if rid and not fname:
      # If an RID was given, but the base UID does not exist:
      # Drop RID (we will create a new non-recurring event) ...
      eid, rid = uid, None
    # ~ print (f"### fname = {fname}, uid = {uid}, rid = {rid}")

    # Determine existing calendar and event ...
    calendar = self.cacheGetCalendar (uid)   # pass UID, not EID, since the EID may not exist yet while the UID does
    event = self.cacheGetEvent (eid, calendar)

    # Create new calendar if necessary ...
    # ~ print (f"###   calendar = {calendar}")
    if not calendar:
      calendar = Calendar ()
      calendar.add ("PRODID", "Home2L " + home2l.EnvGet("home2l.version"))
      calendar.add ("VERSION", "2.0")

    # Create new event if necessary ...
    if not event:
      event = Event ()
      event.add ("DTSTAMP", datetime.now())
      event.add ("UID", uid)
      # ~ if rid: event.add ("RECURRENCE-ID", rid)
      if rid: event ["RECURRENCE-ID"] = rid
      # ~ print (f"###   calendar = {calendar}")
      calendar.add_component (event)
      # ~ print (f"###   calendar = {calendar}")

    # Apply ...
    eventPatchFromReminder (event, remMain)

    # Write calendar to file ...
    if not fname: fname = uid + ".ics"
    self.cacheWriteCalendar (fname, calendar)





######################### Vdirsyncher Background Service #######################


syncerProcess = None
syncerTNextFull = None
syncerTriggerSet = set()


def syncerIterate ():
  global syncerProcess, syncerTNextFull, syncerTriggerSet

  runSyncer = None

  # Background process still running ...
  if syncerProcess:
    ret = syncerProcess.poll()
    if ret is not None:
      if ret != 0:
        print (f"WARNING: vdirsyncher returned non-empty error code {ret}. Output follows.")
        stdout, _ = syncerProcess.communicate()
        print (stdout.decode ("utf-8"), flush = True)
      syncerProcess = None

  # No running background process ...
  if not syncerProcess:

    # Check whether to sync a single calendar ...
    if len (syncerTriggerSet) > 0:
      if len (syncerTriggerSet) > 1:
        # more than one single trigger waiting: trigger a full sync
        syncerTNextFull = None
      else:
        vdirName = syncerTriggerSet.pop ().strip ('/')
        print (f"INFO: Syncing: {vdirName}", flush = True)
        runSyncer = [ vdirName ]

    # Check whether to start a full sync ...
    now = datetime.now ()
    if not syncerTNextFull: syncerTNextFull = now
    if now >= syncerTNextFull:
      print (f"INFO: Syncing all vdirs", flush = True)
      runSyncer = []
      syncerTNextFull += timedelta (minutes = optSyncInterval)

  # Start syncer if requested ...
  if runSyncer != None:
    try:
      syncerProcess = subprocess.Popen (['vdirsyncer', 'sync'] + runSyncer,
                                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    except Exception as e:
      print (f"ERROR: Failed to run vdirsyncer: {e}", flush = True)
      syncerProcess = None


def syncerTrigger (vdir):
  """Trigger the synchronization of a directory."""
  print (f"INFO: Triggering sync: {vdir.getName ()}", flush = True)
  syncerTriggerSet.add (vdir.getName ())
  syncerIterate ()





############################## Socket Server ###################################


vdirMap = {}


def serverHandleLine (sock, line):
  """Process a command. Returns 'True' if it was the last command, else 'False'."""
  print (f"INFO: Received: '{line}'", flush = True)

  # Sanity ...
  line = line.strip ()
  if not line: return

  # Split line ...
  cmd, vdirName, args = (line.split (maxsplit = 2) + [ None, None ]) [:3]

  # Load or get vdir, if second argument is present ...
  if vdirName:
    if not vdirName in vdirMap: vdirMap[vdirName] = VDir (vdirName)
    vdir = vdirMap[vdirName]

    # Check for external modifications and update cache ...
    vdir.cacheUpdate ()

  # Command: Quit
  if cmd == "q":
    return True

  # Command: info ...
  #   Syntax: i <vdir>
  elif cmd == "i":
    reply = "{}:{}\n".format (vdir.getColor (), vdir.getDisplayName ())
    sock.sendall (reply.encode ("utf-8"))

  # Command: list ...
  #   Syntax: ? <vdir> <date0> <date1>
  elif cmd == "?":
    try:
      arg1, arg2 = args.split ()
      d0 = datetime.fromisoformat (arg1)
      d1 = datetime.fromisoformat (arg2)
    except Exception as e:
      raise SyntaxError (f"Invalid arguments to command: {line}")
    reply = vdir.getEventList (d0, d1) + ".\n"
    sock.sendall (reply.encode ("utf-8"))

  # Command: delete ...
  #   Syntax: - <vdir> <eid>
  elif cmd == "-":
    eid = args.strip ().lstrip ("@")
    vdir.delEvent (eid)
    syncerTrigger (vdir)

  # Command: change / add ...
  #   Syntax: + <vdir> <reminder>
  elif cmd == "+":
    vdir.chgEvent (args)
    syncerTrigger (vdir)

  # Done: Return to not stop ...
  return False


def serverRun ():
  """Run socket server infinitely."""

  try:

    # Create socket ...
    if optSocket: socketSpec = optSocket
    else: socketSpec = str (Path (home2l.EnvHome2lVar (), "home2l-pimd.sock"))
    if socketSpec[0] == '/':

      # Create and bind a Unix domain socket ...
      if os.path.exists (socketSpec): os.remove (socketSpec)
      sock = socket.socket (socket.AF_UNIX, socket.SOCK_STREAM)
      sock.bind (socketSpec)
      os.chmod (socketSpec, 0o770)      # allow full access to the group of the caller
      print (f"INFO: Listening on unix domain socket: {socketSpec}", flush = True)

    else:

      # Create and bind TCP/IP socket ...
      sock = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
      sock.bind (("0.0.0.0", int (socketSpec)))
      print (f"INFO: Listening on port {socketSpec}", flush = True)

    # Listen ...
    sock.listen (32)   # allow up to 32 connections before refusing new ones

    # Main server loop ...
    while True:

      # Iterate background task(s) ...
      syncerIterate ()

      # Wait for a connection ...
      try:
        sock.settimeout (10)         # set a timeout of 10 seconds for accept
        sockConn, clientAddress = sock.accept ()
        sockConn.settimeout (None)   # clear the timeout for other operations
        if not clientAddress: clientAddress = socketSpec
      except socket.timeout:
        # skip iterate background tasks
        continue

      # Handle connection ...
      try:
        print (f"INFO: {clientAddress}: connected", flush = True)

        buffer = ""
        done = False
        while not done:
          data = sockConn.recv (4096)
          # ~ print (f"INFO: data = '{data}'")

          # Accumulate and process lines as possible ...
          if not data: done = True
          else:
            buffer += data.decode ("utf-8")
            # ~ print (f"INFO: buffer = '{buffer}'")
            while not done and "\n" in buffer:
              line, buffer = buffer.split ("\n", maxsplit=1)
              try:
                done = serverHandleLine (sockConn, line)
              except SyntaxError as e:
                sockConn.sendall (f"E: {e}\n".encode ("utf-8"))
                print (f"WARNING: {e}", flush = True)

      except BrokenPipeError:
        print (f"INFO: {clientAddress}: broken pipe", flush = True)

      finally:
        # Clean up the connection ...
        print (f"INFO: {clientAddress}: disconnected", flush = True)
        sockConn.close()

  except KeyboardInterrupt:
    print ("INFO: Interrupted.", flush = True)

  finally:
    # Clean up the socket
    sock.close()
    if socketSpec[0] == '/': os.remove (socketSpec)





############################## Main ############################################


def Usage (code):
  print ("Usage: " + sys.argv[0].rsplit('/', 1)[-1] + " [<options>] <vdir root>\n\n"
    "Options:\n"
    "  -h : Help\n"
    "  -s : Socket: absolute path (Unix) or port number (TCP)\n"
    "       Default: <Home2L var>/home2l-pimd.sock\n"
    "  -i : Interval to call 'vdirsyncer'\n"
    "       Default: " + str(optSyncInterval) + " minutes\n"
  )
  exit (code)


# Parse arguments...
args = sys.argv[1:]
try:
  while len (args) > 1:
    if args[0] == '-h':
      Usage (0)
    if args[0] == '-s':
      optSocket = args[1]
      args = args[2:]
    if args[0] == '-i':
      optSyncInterval = int (args[1])
  optVdirRoot = args[0]
except:
  Usage (3)

# Go ahead ...
home2l.Home2lInit (args = False)    # Print banner with version, do not interpret standard Home2L args
serverRun ()
