<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Home2L - Python API: Rules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="home2l-icon-web.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Home2L - Python API
   &#160;<span id="projectnumber">v1.2-0-ga055 (2022-08-31)</span>
   </div>
   <div id="projectbrief">Smart Tools for a Private Home</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Rules<div class="ingroups"><a class="el" href="group__home2l.html">Home2L</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Running functions on resource updates, on events or at certain times. </p>
<div class="dynheader">
Collaboration diagram for Rules:</div>
<div class="dyncontent">
<div class="center"><img src="group__home2l__rules.png" border="0" usemap="#agroup____home2l____rules" alt=""/></div>
<map name="agroup____home2l____rules" id="agroup____home2l____rules">
<area shape="rect" href="group__home2l.html" title="Top&#45;level of the Home2L Python package." alt="" coords="5,5,76,31"/>
<area shape="rect" title="Running functions on resource updates, on events or at certain times." alt="" coords="124,5,180,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6cda430cd4adc375ee6f5817fdad0d7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga6cda430cd4adc375ee6f5817fdad0d7d">RunOnEvent</a> (func, rcSet=None, data=None, subscrId=None)</td></tr>
<tr class="memdesc:ga6cda430cd4adc375ee6f5817fdad0d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to be called on events.  <a href="group__home2l__rules.html#ga6cda430cd4adc375ee6f5817fdad0d7d">More...</a><br /></td></tr>
<tr class="separator:ga6cda430cd4adc375ee6f5817fdad0d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2cf772db34d7e81dc298dff244c1b6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#gafb2cf772db34d7e81dc298dff244c1b6">onEvent</a> (*rcSet)</td></tr>
<tr class="memdesc:gafb2cf772db34d7e81dc298dff244c1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator to define a function to be called on events.  <a href="group__home2l__rules.html#gafb2cf772db34d7e81dc298dff244c1b6">More...</a><br /></td></tr>
<tr class="separator:gafb2cf772db34d7e81dc298dff244c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c3e1dbdda42c97f64bd067ac59e150"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga70c3e1dbdda42c97f64bd067ac59e150">RunOnUpdate</a> (func, rcSet=None, subscrId=None)</td></tr>
<tr class="memdesc:ga70c3e1dbdda42c97f64bd067ac59e150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to be called on value/state changes of resources.  <a href="group__home2l__rules.html#ga70c3e1dbdda42c97f64bd067ac59e150">More...</a><br /></td></tr>
<tr class="separator:ga70c3e1dbdda42c97f64bd067ac59e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef083f026035f58984ce5800b01e379"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#gabef083f026035f58984ce5800b01e379">onUpdate</a> (*rcSet)</td></tr>
<tr class="memdesc:gabef083f026035f58984ce5800b01e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator to define a function to be called on value/state changes.  <a href="group__home2l__rules.html#gabef083f026035f58984ce5800b01e379">More...</a><br /></td></tr>
<tr class="separator:gabef083f026035f58984ce5800b01e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5846a72ab221ad653c3d19900fc1101a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga5846a72ab221ad653c3d19900fc1101a">Connect</a> (target, rcSet, func=lambda x:x, attrs=None, id=None, priority=None, t0=None, hysteresis=None, delDelay=None, subscrId=None)</td></tr>
<tr class="memdesc:ga5846a72ab221ad653c3d19900fc1101a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a connector between resources.  <a href="group__home2l__rules.html#ga5846a72ab221ad653c3d19900fc1101a">More...</a><br /></td></tr>
<tr class="separator:ga5846a72ab221ad653c3d19900fc1101a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b3341fc2f766012cf00feefb201182"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga60b3341fc2f766012cf00feefb201182">connect</a> (target, rcSet, attrs=None, id=None, priority=None, t0=None, hysteresis=None, delDelay=None)</td></tr>
<tr class="memdesc:ga60b3341fc2f766012cf00feefb201182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator to define a connector.  <a href="group__home2l__rules.html#ga60b3341fc2f766012cf00feefb201182">More...</a><br /></td></tr>
<tr class="separator:ga60b3341fc2f766012cf00feefb201182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8617bb7a5492e7e0a2751f4d47cd6cc7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga8617bb7a5492e7e0a2751f4d47cd6cc7">RunAt</a> (func, t=0, dt=0, args=None, subscrId=None)</td></tr>
<tr class="memdesc:ga8617bb7a5492e7e0a2751f4d47cd6cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let a function be called at a given time or periodically.  <a href="group__home2l__rules.html#ga8617bb7a5492e7e0a2751f4d47cd6cc7">More...</a><br /></td></tr>
<tr class="separator:ga8617bb7a5492e7e0a2751f4d47cd6cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f3677f3b9441a4aeedbc1bdb98a815"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#gaa8f3677f3b9441a4aeedbc1bdb98a815">at</a> (t=0, dt=0, args=None)</td></tr>
<tr class="memdesc:gaa8f3677f3b9441a4aeedbc1bdb98a815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator to let a function be called at a given time or periodically.  <a href="group__home2l__rules.html#gaa8f3677f3b9441a4aeedbc1bdb98a815">More...</a><br /></td></tr>
<tr class="separator:gaa8f3677f3b9441a4aeedbc1bdb98a815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga414fe36f2d5ae7a819a1482a6577cafc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga414fe36f2d5ae7a819a1482a6577cafc">RunDaily</a> (func, hostSet=None, data=None, subscrId=None)</td></tr>
<tr class="memdesc:ga414fe36f2d5ae7a819a1482a6577cafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let a function be called daily for setting permanent requests.  <a href="group__home2l__rules.html#ga414fe36f2d5ae7a819a1482a6577cafc">More...</a><br /></td></tr>
<tr class="separator:ga414fe36f2d5ae7a819a1482a6577cafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1fed4c282ec1eff455b9c2a8253d6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__home2l__rules.html#ga7a1fed4c282ec1eff455b9c2a8253d6d">daily</a> (*hostSet)</td></tr>
<tr class="memdesc:ga7a1fed4c282ec1eff455b9c2a8253d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator to let a function be called daily for setting permanent requests.  <a href="group__home2l__rules.html#ga7a1fed4c282ec1eff455b9c2a8253d6d">More...</a><br /></td></tr>
<tr class="separator:ga7a1fed4c282ec1eff455b9c2a8253d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6cda430cd4adc375ee6f5817fdad0d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cda430cd4adc375ee6f5817fdad0d7d">&#9670;&nbsp;</a></span>RunOnEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.RunOnEvent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcSet</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subscrId</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a function to be called on events. </p>
<pre class="fragment">Define a function to be called whenever an event for a set of
resources occurs.

'rcSet' can either be a 'CResource' object, an URI string or a tuple
or a list of any of those. 'data' is an optional reference to user
data that will be passed unchanged to any 'func' invocations.

For each event encountered, the function 'func' will be called as follows:

    func (ev, rc, vs [ , data ] )

where '(ERcEventType) ev' is the type of event, 'rc' is the affected
resource, and, if applicable, 'vs' is the new value and state that
has been reported for the resource.

The event type 'ev' can be one of the following:
    rceValueStateChanged : The value or state has changed.
    rceConnected         : The connection has been (re-)established.
    rceDisconnected      : The connection has been lost.

Unlike 'RunOnUpdate', the function 'func' will be called for each single
event in the correct order in time, so that no temporary value changes
get lost.

The parameter 'subscrId' sets the subscriber ID. It can usually be left unspecified,
in which case, the function name is used as an identifier.
</pre> 
</div>
</div>
<a id="gafb2cf772db34d7e81dc298dff244c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2cf772db34d7e81dc298dff244c1b6">&#9670;&nbsp;</a></span>onEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.onEvent </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>rcSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorator to define a function to be called on events. </p>
<pre class="fragment">Decorator variant of 'RunOnEvent()'.

This decorator allows to easily let a function be executed on given events
as follows:

|   @onEvent (&lt;resource set&gt;)
|   def MyFunc (ev, rc, vs):
|     ...</pre> 
</div>
</div>
<a id="ga70c3e1dbdda42c97f64bd067ac59e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c3e1dbdda42c97f64bd067ac59e150">&#9670;&nbsp;</a></span>RunOnUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.RunOnUpdate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcSet</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subscrId</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a function to be called on value/state changes of resources. </p>
<pre class="fragment">Define a function to be called on value/state changes of resources.

For if any of the specified resources changes its value or state,
the function 'func' will be called as follows

    func (a, b, c, ...)

where "a, b, c, ..." are arbitrary positional arguments, which (if present)
are filled with the current values of the resources specified by 'rcSet'.
The arguments are optional, and their names can be chosen arbitratily.
Values are filled in in the same order as the ordering of the resources
specified by 'rcSet'. The values are obtained by CResource.Value().

'rcSet' can either be a 'CResource' object, an URI string or a tuple
or a list of any of those.

Unlike 'RunOnEvent', only 'rceValueStateChanged' events cause
invocations of 'func', and multiple events quickly following each
other may be merged to a single invocation, so that only the last value
is actually reported. For this reason, this mechanism is generally more
efficient and should be preferred if short intermediate value changes
are not of interest.

Important: Resource states and values may change any time. If resource
values (or states) are queried again within the function, they may differ
from the result of a previous query.

The parameter 'subscrId' sets the subscriber ID. It can usually be left unspecified,
in which case, the function name is used as an identifier.
</pre> 
</div>
</div>
<a id="gabef083f026035f58984ce5800b01e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef083f026035f58984ce5800b01e379">&#9670;&nbsp;</a></span>onUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.onUpdate </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>rcSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorator to define a function to be called on value/state changes. </p>
<pre class="fragment">Decorator variant of 'RunOnUpdate()'.

This decorator allows to easily define a function executed on value changes
as follows:

|   @onUpdate ( &lt;resource set&gt; )
|   def MyFunc ():
|     ...</pre> 
</div>
</div>
<a id="ga5846a72ab221ad653c3d19900fc1101a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5846a72ab221ad653c3d19900fc1101a">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.Connect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>lambda&#160;x:&#160;x</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>id</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>priority</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hysteresis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delDelay</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subscrId</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a connector between resources. </p>
<pre class="fragment">Connect source (sensor) resource(s) to a target (actor) resource.

This creates a connector, which continuously updates requests for the target
resource 'target' based on a transfer function depending on the values of
the resources given by 'rcSet'.

'target' specifies the target resource - either by its URI or by a
'CResource' reference.

'rcSet' specifies the source (sensor) resource(s). It may be a single
resource or a tuple or list of multiple resources.

'func' is the transfer function transforming source (sensor) values into
request values for the target resource. It is called as:

    value = func (a, b, c, ...)

'a, b, c, ...' are positional arguments with arbitrary names by which the
values of the 'rcSet' resources are passed. The function must return the actual
value requested for 'target'. If 'None' is returned, the request is deleted
(eventually after a delay specified by 'delDelay'). The default for 'func' is
the identiy function, transporting source values directly without modifications.

The remaining arguments ('attrs', 'id', ..., 'delDelay') specify the request
attributes used for placing the respective requests. See RcSetRequest() for
details. Multiple connectors can be defined with different request IDs
and priorities, and the request resolution mechanism will resolve them
properly. This way, complex automation rules can be specified (one example is
given below).

Notes on writing transfer functions ('func'):

1. Any of the arguments 'a, b, c, ...' may also be 'None' if the respective
   resource has a state of 'rcsUnkown'. This must be considered when writing
   transfer functions. For example, to check whether a Boolean resource x is
   known and false, the expression should be 'if x == False: ...' instead of
   'if not x: ...', since in the latter case 'not x' would evaluate as true,
   if x is 'None'. In general, Boolean resource values should always be used
   in conjunction with a comparision. For example, an expression like
   'a and b' may be written as '(a == True) and (b != False)', which implies,
   that a value of 'None' is treated like 'False' for 'a', but like 'True'
   for 'b'.

2. To facilitate function writing, especially if the source resources have
   numerical types, 'TypeError' exceptions are caught by the caller and result
   in a return value of 'None'. 'TypeError' exceptions are typically raised
   if one of the arguments of an arithmetic exception is 'None'.

3. The transfer function is evaluated whenever a value/state change occurs for
   any of the resources of 'rcSet', but only then. If resources are read
   inside the gate function, they usually must be contained in 'rcSet'.
   It is good practice to not read out resources directly, but only rely
   on the arguments passed to the gate function.

Examples:

- Let a light be switched on for 5 seconds if a motion sensor is activated, but only
  at night time:

  |   rcLight = RcGet ('/alias/light')  # get reference to the light resource
  |   rcLight.SetDefault (0)            # set default request: light off (0)
  |   Connect (rcLight, '/alias/day', lamda x: 0 if x == True else None, attrs = '#daytime *3')
  |     # keep light off (0) at day time (True) at high priority (*3)
  |   Connect (rcLight, '/alias/motion', lamda x: 1 if x == True else None, attrs = '#motion *2', delDelay = '5s')
  |     # switch light on (1) if the motion detector is active at a lower
  |     # priority (*2); after the motion sensor becomes inactive, the request
  |     # is deleted with a delay of 5 seconds ('5s')

- Force the light off at day time, but during rainy weather:

  |   Connect (rcLight, ('/alias/motion', '/alias/rain'), lamda m, r: 0 if m == True and not r == True else None)

  or alternatively (decorator variant):

  |   @connect (rcLight, ('/alias/motion', '/alias/rain')):
  |   def LightOffDuringDayAndGoodWeather (motion, rain):
  |     # (some additional code may be added here)
  |     if motion == True and not rain == True: return 0
  |     else: return None
</pre> 
</div>
</div>
<a id="ga60b3341fc2f766012cf00feefb201182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60b3341fc2f766012cf00feefb201182">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.connect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>id</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>priority</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hysteresis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delDelay</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorator to define a connector. </p>
<pre class="fragment">Decorator variant of 'Connect()'.

This allows to decorate a transfer function, thus creating a connector,
which continuously updates requests for the target resource 'target' depending
on the values of the resources given by 'rcSet':

|   @connect ( &lt;target&gt;, &lt;rcSet&gt; [, &lt;request attrs&gt;] )
|   def TransferFunc (a, b, c, ...):
|     ...
|     return &lt;value&gt;</pre> 
</div>
</div>
<a id="ga8617bb7a5492e7e0a2751f4d47cd6cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8617bb7a5492e7e0a2751f4d47cd6cc7">&#9670;&nbsp;</a></span>RunAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.RunAt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subscrId</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let a function be called at a given time or periodically. </p>
<pre class="fragment">Define a function to be called at a given time, optionally repeated
at regular intervals.

The starting time 't' can be specified by anything accepted by 'TicksAbsOf()'.
The interval 'dt' (if given) can be anything accepted by 'TicksRelOf()'.
If 'dt' &lt;= 0, the timer is executed once and then deactivated. Otherwise,
the function is repeated regularly.

The function 'func' will be called as follows:

    func (&lt;args&gt;)

where &lt;args&gt; is the 'args' object passed to 'RunAt()', if 'func' has just one
argument and 'args' it is neither a tuple nor a dictionary.
If 'func' has at least two arguments and 'args' is a tuple or a dictionary,
its components are passed as individual arguments to 'func', either as
positional (tuple) or keyword (dictionary) arguments, respectively.

If 'subscrId' is not set, the function name will be used as an ID.
Calling this function again with the same ID causes the old timer to be deleted.
Presently, there is no mechanism to delete a previously defined timer.
</pre> 
</div>
</div>
<a id="gaa8f3677f3b9441a4aeedbc1bdb98a815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f3677f3b9441a4aeedbc1bdb98a815">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.at </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorator to let a function be called at a given time or periodically. </p>
<pre class="fragment">Decorator variant of 'RunAt()'.

This decorator allows to execute a function at given times
as follows:

|   @at ( t = &lt;t&gt; [, dt = &lt;interval&gt;] [, args = &lt;args&gt;] )
|   def MyTimedFunc ( [&lt;args&gt;] ):
|     ...</pre> 
</div>
</div>
<a id="ga414fe36f2d5ae7a819a1482a6577cafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga414fe36f2d5ae7a819a1482a6577cafc">&#9670;&nbsp;</a></span>RunDaily()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.RunDaily </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hostSet</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subscrId</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let a function be called daily for setting permanent requests. </p>
<pre class="fragment">Define a function to be called daily or whenever one of the hosts becomes
reachable (again).

This can be used to set and keep persistent permanent requests in rules scripts.
'hostSet' can either be a single string or a tuple or a list of strings.
'data' is an optional reference to user data that will be passed unchanged to
any 'func' invocations.

Whenever a host or a set of hosts becomes reachable, the function 'func' will
be called as follows:

    func ( [host [ , data ] ] )

'host' is the host name for which rules must be updated.
Arguments are passed as keyword arguments. Hence, the names must match,
and unsused arguments can be abbreviated by '**kwargs'.

Important: On each host in the set, the 'timer' driver must be enabled.

The parameter 'subscrId' can usually be left unspecified. In this case, the function
names are used as identifiers.
</pre> 
</div>
</div>
<a id="ga7a1fed4c282ec1eff455b9c2a8253d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1fed4c282ec1eff455b9c2a8253d6d">&#9670;&nbsp;</a></span>daily()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def home2l.daily </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>hostSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorator to let a function be called daily for setting permanent requests. </p>
<pre class="fragment">Decorator variant of 'RunDaily'.

This decorator allows to easily define a function executed daily or whenever
a host becomes reachable (again) as follows:

|   @daily ( [ &lt;host set&gt; ] )
|   def MyFunc (host):
|     ...</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
